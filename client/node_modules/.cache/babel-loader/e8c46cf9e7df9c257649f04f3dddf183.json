{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { useRef, useCallback, useMemo } from 'react';\nimport { Form } from 'react-final-form';\nimport arrayMutators from 'final-form-arrays';\nimport useInitializeFormWithRecord from './useInitializeFormWithRecord';\nimport sanitizeEmptyValues from './sanitizeEmptyValues';\nimport getFormInitialValues from './getFormInitialValues';\nimport FormContext from './FormContext';\n/**\n * Wrapper around react-final-form's Form to handle redirection on submit,\n * legacy defaultValue prop, and array inputs.\n *\n * Requires a render function, just like react-final-form\n *\n * @example\n *\n * const SimpleForm = props => (\n *    <FormWithRedirect\n *        {...props}\n *        render={formProps => <SimpleFormView {...formProps} />}\n *    />\n * );\n *\n * @typedef {Object} Props the props you can use (other props are injected by Create or Edit)\n * @prop {Object} initialValues\n * @prop {Function} validate\n * @prop {Function} save\n * @prop {boolean} submitOnEnter\n * @prop {string} redirect\n *\n * @param {Prop} props\n */\n\nvar FormWithRedirect = function (_a) {\n  var initialValues = _a.initialValues,\n      debug = _a.debug,\n      decorators = _a.decorators,\n      defaultValue = _a.defaultValue,\n      form = _a.form,\n      initialValuesEqual = _a.initialValuesEqual,\n      _b = _a.keepDirtyOnReinitialize,\n      keepDirtyOnReinitialize = _b === void 0 ? true : _b,\n      _c = _a.mutators,\n      mutators = _c === void 0 ? arrayMutators : _c,\n      // FIXME see https://github.com/final-form/react-final-form/issues/704 and https://github.com/microsoft/TypeScript/issues/35771\n  record = _a.record,\n      render = _a.render,\n      save = _a.save,\n      saving = _a.saving,\n      _d = _a.subscription,\n      subscription = _d === void 0 ? defaultSubscription : _d,\n      validate = _a.validate,\n      validateOnBlur = _a.validateOnBlur,\n      version = _a.version,\n      props = __rest(_a, [\"initialValues\", \"debug\", \"decorators\", \"defaultValue\", \"form\", \"initialValuesEqual\", \"keepDirtyOnReinitialize\", \"mutators\", \"record\", \"render\", \"save\", \"saving\", \"subscription\", \"validate\", \"validateOnBlur\", \"version\"]);\n\n  var redirect = useRef(props.redirect);\n  var onSave = useRef(save); // We don't use state here for two reasons:\n  // 1. There no way to execute code only after the state has been updated\n  // 2. We don't want the form to rerender when redirect is changed\n\n  var setRedirect = function (newRedirect) {\n    redirect.current = newRedirect;\n  };\n  /**\n   * A form can have several Save buttons. In case the user clicks on\n   * a Save button with a custom onSave handler, then on a second Save button\n   * without custom onSave handler, the user expects the default save\n   * handler (the one of the Form) to be called.\n   * That's why the SaveButton onClick calls setOnSave() with no parameters\n   * if it has no custom onSave, and why this function forces a default to\n   * save.\n   */\n\n\n  var setOnSave = useCallback(function (newOnSave) {\n    typeof newOnSave === 'function' ? onSave.current = newOnSave : onSave.current = save;\n  }, [save]);\n  var formContextValue = useMemo(function () {\n    return {\n      setOnSave: setOnSave\n    };\n  }, [setOnSave]);\n  var finalInitialValues = getFormInitialValues(initialValues, defaultValue, record);\n\n  var submit = function (values) {\n    var finalRedirect = typeof redirect.current === undefined ? props.redirect : redirect.current;\n    var finalValues = sanitizeEmptyValues(finalInitialValues, values);\n    onSave.current(finalValues, finalRedirect);\n  };\n\n  return React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, React.createElement(Form, {\n    key: version,\n    debug: debug,\n    decorators: decorators,\n    form: form,\n    initialValues: finalInitialValues,\n    initialValuesEqual: initialValuesEqual,\n    keepDirtyOnReinitialize: keepDirtyOnReinitialize,\n    mutators: mutators,\n    onSubmit: submit,\n    subscription: subscription,\n    validate: validate,\n    validateOnBlur: validateOnBlur\n  }, function (formProps) {\n    return React.createElement(FormView, __assign({}, props, formProps, {\n      record: record,\n      setRedirect: setRedirect,\n      saving: formProps.submitting || saving,\n      render: render,\n      save: save\n    }));\n  }));\n};\n\nvar defaultSubscription = {\n  submitting: true,\n  pristine: true,\n  valid: true,\n  invalid: true\n};\n\nvar FormView = function (_a) {\n  var render = _a.render,\n      props = __rest(_a, [\"render\"]); // if record changes (after a getOne success or a refresh), the form must be updated\n\n\n  useInitializeFormWithRecord(props.record);\n  var redirect = props.redirect,\n      setRedirect = props.setRedirect,\n      handleSubmit = props.handleSubmit;\n  /**\n   * We want to let developers define the redirection target from inside the form,\n   * e.g. in a <SaveButton redirect=\"list\" />.\n   * This callback does two things: handle submit, and change the redirection target.\n   * The actual redirection is done in save(), passed by the main controller.\n   *\n   * If the redirection target doesn't depend on the button clicked, it's a\n   * better option to define it directly on the Form component. In that case,\n   * using handleSubmit() instead of handleSubmitWithRedirect is fine.\n   *\n   * @example\n   *\n   * <Button onClick={() => handleSubmitWithRedirect('edit')}>\n   *     Save and edit\n   * </Button>\n   */\n\n  var handleSubmitWithRedirect = useCallback(function (redirectTo) {\n    if (redirectTo === void 0) {\n      redirectTo = redirect;\n    }\n\n    setRedirect(redirectTo);\n    handleSubmit();\n  }, [setRedirect, redirect, handleSubmit]);\n  return render(__assign(__assign({}, props), {\n    handleSubmitWithRedirect: handleSubmitWithRedirect\n  }));\n};\n\nexport default FormWithRedirect;","map":null,"metadata":{},"sourceType":"module"}