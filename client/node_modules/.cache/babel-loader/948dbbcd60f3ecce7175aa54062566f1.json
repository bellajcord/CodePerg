{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { useCallback, useEffect, useRef, useState, useMemo, isValidElement } from 'react';\nimport Downshift from 'downshift';\nimport get from 'lodash/get';\nimport { makeStyles, TextField } from '@material-ui/core';\nimport { useInput, FieldTitle, useSuggestions, warning } from 'ra-core';\nimport InputHelperText from './InputHelperText';\nimport AutocompleteSuggestionList from './AutocompleteSuggestionList';\nimport AutocompleteSuggestionItem from './AutocompleteSuggestionItem';\n/**\n * An Input component for an autocomplete field, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property an the option text\n * @example\n * const choices = [\n *    { id: 'M', name: 'Male' },\n *    { id: 'F', name: 'Female' },\n * ];\n * <AutocompleteInput source=\"gender\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },\n *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },\n * ];\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that will be cloned and receive\n * the related choice as the `record` prop. You can use Field components there.\n * Note that you must also specify the `matchSuggestion` prop\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue);\n * const FullNameField = ({ record }) => <span>{record.first_name} {record.last_name}</span>;\n * <SelectInput source=\"gender\" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} />\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'M', name: 'myroot.gender.male' },\n *    { id: 'F', name: 'myroot.gender.female' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <AutocompleteInput source=\"gender\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the material-ui <TextField> component\n *\n * @example\n * <AutocompleteInput source=\"author_id\" options={{ color: 'secondary', InputLabelProps: { shrink: true } }} />\n */\n\nvar AutocompleteInput = function (props) {\n  var allowEmpty = props.allowEmpty,\n      className = props.className,\n      classesOverride = props.classes,\n      _a = props.choices,\n      choices = _a === void 0 ? [] : _a,\n      emptyText = props.emptyText,\n      emptyValue = props.emptyValue,\n      format = props.format,\n      fullWidth = props.fullWidth,\n      helperText = props.helperText,\n      idOverride = props.id,\n      inputOverride = props.input,\n      isRequiredOverride = props.isRequired,\n      label = props.label,\n      limitChoicesToValue = props.limitChoicesToValue,\n      _b = props.margin,\n      margin = _b === void 0 ? 'dense' : _b,\n      matchSuggestion = props.matchSuggestion,\n      metaOverride = props.meta,\n      onBlur = props.onBlur,\n      onChange = props.onChange,\n      onFocus = props.onFocus,\n      _c = props.options,\n      _d = _c === void 0 ? {\n    suggestionsContainerProps: undefined,\n    labelProps: undefined,\n    InputProps: undefined\n  } : _c,\n      suggestionsContainerProps = _d.suggestionsContainerProps,\n      labelProps = _d.labelProps,\n      InputProps = _d.InputProps,\n      options = __rest(_d, [\"suggestionsContainerProps\", \"labelProps\", \"InputProps\"]),\n      _e = props.optionText,\n      optionText = _e === void 0 ? 'name' : _e,\n      inputText = props.inputText,\n      _f = props.optionValue,\n      optionValue = _f === void 0 ? 'id' : _f,\n      parse = props.parse,\n      resource = props.resource,\n      setFilter = props.setFilter,\n      shouldRenderSuggestionsOverride = props.shouldRenderSuggestions,\n      source = props.source,\n      suggestionLimit = props.suggestionLimit,\n      _g = props.translateChoice,\n      translateChoice = _g === void 0 ? true : _g,\n      validate = props.validate,\n      _h = props.variant,\n      variant = _h === void 0 ? 'filled' : _h,\n      rest = __rest(props, [\"allowEmpty\", \"className\", \"classes\", \"choices\", \"emptyText\", \"emptyValue\", \"format\", \"fullWidth\", \"helperText\", \"id\", \"input\", \"isRequired\", \"label\", \"limitChoicesToValue\", \"margin\", \"matchSuggestion\", \"meta\", \"onBlur\", \"onChange\", \"onFocus\", \"options\", \"optionText\", \"inputText\", \"optionValue\", \"parse\", \"resource\", \"setFilter\", \"shouldRenderSuggestions\", \"source\", \"suggestionLimit\", \"translateChoice\", \"validate\", \"variant\"]);\n\n  if (isValidElement(optionText) && !inputText) {\n    throw new Error(\"If the optionText prop is a React element, you must also specify the inputText prop:\\n        <AutocompleteInput\\n            inputText={(record) => record.title}\\n        />\");\n  }\n\n  warning(isValidElement(optionText) && !matchSuggestion, \"If the optionText prop is a React element, you must also specify the matchSuggestion prop:\\n<AutocompleteInput\\n    matchSuggestion={(filterValue, suggestion) => true}\\n/>\\n        \");\n  var classes = useStyles(props);\n  var inputEl = useRef();\n  var anchorEl = useRef();\n\n  var _j = useInput(__assign({\n    format: format,\n    id: idOverride,\n    input: inputOverride,\n    meta: metaOverride,\n    onBlur: onBlur,\n    onChange: onChange,\n    onFocus: onFocus,\n    parse: parse,\n    resource: resource,\n    source: source,\n    validate: validate\n  }, rest)),\n      id = _j.id,\n      input = _j.input,\n      isRequired = _j.isRequired,\n      _k = _j.meta,\n      touched = _k.touched,\n      error = _k.error;\n\n  var _l = useState(''),\n      filterValue = _l[0],\n      setFilterValue = _l[1];\n\n  var getSuggestionFromValue = useCallback(function (value) {\n    return choices.find(function (choice) {\n      return get(choice, optionValue) === value;\n    });\n  }, [choices, optionValue]);\n  var selectedItem = useMemo(function () {\n    return getSuggestionFromValue(input.value) || null;\n  }, [input.value, getSuggestionFromValue]);\n\n  var _m = useSuggestions({\n    allowEmpty: allowEmpty,\n    choices: choices,\n    emptyText: emptyText,\n    emptyValue: emptyValue,\n    limitChoicesToValue: limitChoicesToValue,\n    matchSuggestion: matchSuggestion,\n    optionText: optionText,\n    optionValue: optionValue,\n    selectedItem: selectedItem,\n    suggestionLimit: suggestionLimit,\n    translateChoice: translateChoice\n  }),\n      getChoiceText = _m.getChoiceText,\n      getChoiceValue = _m.getChoiceValue,\n      getSuggestions = _m.getSuggestions;\n\n  var handleFilterChange = useCallback(function (eventOrValue) {\n    var event = eventOrValue;\n    var value = event.target ? event.target.value : eventOrValue;\n\n    if (setFilter) {\n      setFilter(value);\n    }\n  }, [setFilter]); // We must reset the filter every time the value changes to ensure we\n  // display at least some choices even if the input has a value.\n  // Otherwise, it would only display the currently selected one and the user\n  // would have to first clear the input before seeing any other choices\n\n  useEffect(function () {\n    handleFilterChange(''); // If we have a value, set the filter to its text so that\n    // Downshift displays it correctly\n\n    setFilterValue(input.value ? inputText ? inputText(getChoiceText(selectedItem).props.record) : getChoiceText(selectedItem) : '');\n  }, [input.value, handleFilterChange, selectedItem, getChoiceText, inputText]);\n  var handleChange = useCallback(function (item) {\n    input.onChange(getChoiceValue(item));\n  }, [getChoiceValue, input]); // This function ensures that the suggestion list stay aligned to the\n  // input element even if it moves (because user scrolled for example)\n\n  var updateAnchorEl = function () {\n    if (!inputEl.current) {\n      return;\n    }\n\n    var inputPosition = inputEl.current.getBoundingClientRect(); // It works by implementing a mock element providing the only method used\n    // by the PopOver component, getBoundingClientRect, which will return a\n    // position based on the input position\n\n    if (!anchorEl.current) {\n      anchorEl.current = {\n        getBoundingClientRect: function () {\n          return inputPosition;\n        }\n      };\n    } else {\n      var anchorPosition = anchorEl.current.getBoundingClientRect();\n\n      if (anchorPosition.x !== inputPosition.x || anchorPosition.y !== inputPosition.y) {\n        anchorEl.current = {\n          getBoundingClientRect: function () {\n            return inputPosition;\n          }\n        };\n      }\n    }\n  };\n\n  var storeInputRef = function (input) {\n    inputEl.current = input;\n    updateAnchorEl();\n  };\n\n  var handleBlur = useCallback(function (event) {\n    handleFilterChange(''); // If we had a value before, set the filter back to its text so that\n    // Downshift displays it correctly\n\n    setFilterValue(input.value ? inputText ? inputText(getChoiceText(selectedItem).props.record) : getChoiceText(selectedItem) : '');\n    input.onBlur(event);\n  }, [getChoiceText, handleFilterChange, input, inputText, selectedItem]);\n  var handleFocus = useCallback(function (openMenu) {\n    return function (event) {\n      openMenu(event);\n      input.onFocus(event);\n    };\n  }, [input]);\n\n  var shouldRenderSuggestions = function (val) {\n    if (shouldRenderSuggestionsOverride !== undefined && typeof shouldRenderSuggestionsOverride === 'function') {\n      return shouldRenderSuggestionsOverride(val);\n    }\n\n    return true;\n  };\n\n  return React.createElement(Downshift, __assign({\n    inputValue: filterValue,\n    onChange: handleChange,\n    selectedItem: selectedItem,\n    itemToString: function (item) {\n      return getChoiceValue(item);\n    }\n  }, rest), function (_a) {\n    var getInputProps = _a.getInputProps,\n        getItemProps = _a.getItemProps,\n        getLabelProps = _a.getLabelProps,\n        getMenuProps = _a.getMenuProps,\n        isOpen = _a.isOpen,\n        highlightedIndex = _a.highlightedIndex,\n        openMenu = _a.openMenu;\n    var isMenuOpen = isOpen && shouldRenderSuggestions(filterValue);\n\n    var _b = getInputProps(__assign({\n      onBlur: handleBlur,\n      onFocus: handleFocus(openMenu)\n    }, InputProps)),\n        downshiftId = _b.id,\n        // We want to ignore this to correctly link our label and the input\n    value = _b.value,\n        onBlur = _b.onBlur,\n        onChange = _b.onChange,\n        onFocus = _b.onFocus,\n        ref = _b.ref,\n        size = _b.size,\n        color = _b.color,\n        inputProps = __rest(_b, [\"id\", \"value\", \"onBlur\", \"onChange\", \"onFocus\", \"ref\", \"size\", \"color\"]);\n\n    var suggestions = getSuggestions(filterValue);\n    return React.createElement(\"div\", {\n      className: classes.container\n    }, React.createElement(TextField, __assign({\n      id: id,\n      name: input.name,\n      InputProps: {\n        inputRef: storeInputRef,\n        onBlur: onBlur,\n        onChange: function (event) {\n          handleFilterChange(event);\n          setFilterValue(event.target.value);\n          onChange(event);\n        },\n        onFocus: onFocus\n      },\n      error: !!(touched && error),\n      label: React.createElement(FieldTitle, __assign({\n        label: label\n      }, labelProps, {\n        source: source,\n        resource: resource,\n        isRequired: typeof isRequiredOverride !== 'undefined' ? isRequiredOverride : isRequired\n      })),\n      InputLabelProps: getLabelProps({\n        htmlFor: id\n      }),\n      helperText: React.createElement(InputHelperText, {\n        touched: touched,\n        error: error,\n        helperText: helperText\n      }),\n      variant: variant,\n      margin: margin,\n      fullWidth: fullWidth,\n      value: filterValue,\n      className: className,\n      size: size,\n      color: color\n    }, inputProps, options)), React.createElement(AutocompleteSuggestionList, {\n      isOpen: isMenuOpen,\n      menuProps: getMenuProps({}, // https://github.com/downshift-js/downshift/issues/235\n      {\n        suppressRefError: true\n      }),\n      inputEl: inputEl.current,\n      suggestionsContainerProps: suggestionsContainerProps\n    }, suggestions.map(function (suggestion, index) {\n      return React.createElement(AutocompleteSuggestionItem, __assign({\n        key: getChoiceValue(suggestion),\n        suggestion: suggestion,\n        index: index,\n        highlightedIndex: highlightedIndex,\n        isSelected: input.value === getChoiceValue(suggestion),\n        filterValue: filterValue,\n        getSuggestionText: getChoiceText\n      }, getItemProps({\n        item: suggestion\n      })));\n    })));\n  });\n};\n\nvar useStyles = makeStyles({\n  root: {\n    flexGrow: 1,\n    height: 250\n  },\n  container: {\n    flexGrow: 1,\n    position: 'relative'\n  }\n}, {\n  name: 'RaAutocompleteInput'\n});\nexport default AutocompleteInput;","map":null,"metadata":{},"sourceType":"module"}